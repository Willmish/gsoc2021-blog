---
layout: post
title: "July"
date: 2021-08-06
categories: Beagleboard updates
---

## Introduction
This being my first post here, a little introduction seems fitting. This is the first post in the upcoming series of posts, updating my progress on the project: Wio Terminal as Zephyr Greybus host. This project is part of my work under the [Beagleboard](https://beagleboard.org/) organization.


## Getting to know Greybus and Zephyr
Since this is my first time working with either of the technologies, I started off by experimenting with both and reading Zephyr's getting started guides, which I highly recommend to anyone new to Zephyr development:
* [Getting started guide](https://docs.zephyrproject.org/latest/getting_started/index.html)
* [Beyond the getting started guide](https://docs.zephyrproject.org/latest/guides/beyond-GSG.html#beyond-gsg)
* [Zephyr application development](https://docs.zephyrproject.org/latest/application/index.html#application)
On top of that, I recommend to read up on [DeviceTree](https://docs.zephyrproject.org/latest/reference/devicetree/index.html#devicetree) as it is used for Zephyr development and it's useful to understand it.

Here is a summary of what I did so far:
* Setting up Zephyr environment
* Flashing blinky on BeagleConnect Freedom + Sensortest sample
* Making some changes to the sample programs to get a feel of Zephyr development
* Building+Flashing [Greybus net demo for GPIO and I2C](https://github.com/jadonk/beagleconnect#24ghz-ieee-802154-greybus-demo-for-gpio-and-i2c)

Plus elements in progress for this milestone:
* Setting up VM with patched Linux Kernel for testing the target device

### Blinky on BeagleConnect Freedom

BeagleConnect Freedom runs a CC1352 MCU and can run Zephyr RTOS on it. First I set up the Zephyr SDK, following the [official Zephyr guide](https://docs.zephyrproject.org/latest/getting_started/index.html). `west` is Zephyr's meta-tool and is a Python package. Whenever you are working with Python, I heavily recommend using virtual environments, to not clutter up your global Python environment.

After some time spent on fiddling with `west` and Zephyr, I have figured out how to properly flash programs on the BeagleConnect Freedom. In order to flash the CC1352 MCU onboard BCF, first MSP430 (which is also on the BCF) needs to be flashed with temporary firmware for flashing CC1352. Afterwards, BeagleConnect Freedom can be flashed with `west`.
As I didn't want to do this by hand each time, I took a look into the existing building/flashing scripts on the [beagleconnect repo](https://github.com/jadonk/beagleconnect/tree/master/sw) and now I use a modifed version of them. With that I flashed a simple blinky program and another sensortest demo which should give the readings of onboard sensors. However, the sensortest demo seems to not work as I expected it to, failing to read the sensor data, so I left it for now.

<!-- TODO Include image here -->

## 2.4GHz and subG IEEE 802.15.4 Greybus demo for GPIO and I2C
After getting some feel for Zephyr, time came to try it with Greybus. I decided that a good starting point would be to try out one of the demo's available on the beagleconnect repo, in particular [2.4GHz IEEE 802.15.4 Greybus demo for GPIO and I2C](https://github.com/jadonk/beagleconnect#24ghz-ieee-802154-greybus-demo-for-gpio-and-i2c). The demo uses a [CC1352R1 Launchpad](https://www.ti.com/tool/LAUNCHXL-CC1352R1), but it should work just fine with the up-to-date BeagleConnect Freedom board running a CC1352. 
Also the 2.4GHz demo initally used an ATUSB device, in order to communicate using IEEE 802.15.4, but there is an alternative - that is using a board (e.g. another BeagleConnect Freedom) as a WPAN usb device (capable of communicating using IEEE 802.15.4).

### Prereading
I have read some articles on it to get a better grasp of it. In particular [Chris Friedt's Post Plumbers Publication gist](https://gist.github.com/cfriedt/1de7ba75c04d0e403cbdcb9555d0c795) shone some light on the topic along with the sources listed by him.

### Flashing the BeagleConnect Freedom with Greybus software
Thanks to my previous fiddling with Zephyr and flashing the BCF, I knew more or less what to do here. In short, I built the [`greybus net` demo program](https://github.com/jadonk/greybus-for-zephyr/tree/a08b3c297e5ac597b93956a76aa2e64043b65f8e/samples/subsys/greybus/net) with mikrobus and flashed it using `west`. Then it was a matter of checking if it flashed correctly by connecting to it via `tio` terminal (`tio /dev/ttyACM0`) and checking whether Zephyr's output is correct.

### Setting up BeagleConnect Freedom as WPAN usb device
**To simplify things, I will be refering to the BeagleConnect flashed with `wpanusb` software as `wpanusb` device, and to the BeagleConnect flashed with greybus simply as BeagleConnect.**
As mentioned above, in order to avoid using a specifc IEEE 802.15.4 adapter/device, a BeagleConnect can be flashed with software which can replace it. First MSP430 needs to be flashed with [usb_uart_bridge software](https://github.com/jadonk/msp430F55xx_usb_uart_bridge) (The guide in the linked repo has a step-by-step guide for this). Then the BeagleConnect can be flashed with the [WPANUSB software](https://github.com/jadonk/wpanusb_bc/tree/ad9515779b4c5cd513ed6e9a6f6cad2ec5b4ab8e), which exports ieee802154 radio over USB to be used in other OSes such as Linux.

Next, in order to use the device, build the [`wpanusb` linux kernel driver](https://github.com/jadonk/wpanusb#configuring-6lowpan-address). The repository linked has a step-by-step guide to configuring a 6lowpan address, which allows you to use the BeagleConnect Freedom flashed with `wpanusb` software to communicate using ieee802154. In short,  you need to run the `modprobe.sh` script to find the `wpanusb` device, then `sudo scripts/lowpan.sh 2 5 && ip -6 monitor dev lowpan0` to create lowpan0 address (2001:db8::2) using channel 5 as well starts a monitor to show status of routes on lowpan0. 

Lastly, to be able to ping the BeagleConnect, you will have to change the ieee802154 channel of the `wpanusb` device to match the BeagleConnect's. To check the BeagleConnect's channel, boot it up and open its terminal e.g. using `tio`: `tio /dev/ttyACM0` (make sure to select the correct port, you can check it in `dmesg` after plugging in the device). 
In the terminal type `ieee802154 get_chan`. To set the channel for the `wpanusb` device you can follow the [demo on beagleconnect repo](https://github.com/jadonk/beagleconnect#set-the-802154-physical-and-link-layer-parameters). In short: first get `phy` number for the `lowpan0` device: `iwpan list`. Next set the channel for the device to match the BeagleConnect's: `sudo iwpan phy {PHY NUMBER} set channel 0 {CHANNEL NUMBER}`.
Now you should be able to ping the Zephyr device from your linux machine using `ping6 -I lowpan0 2001:db8::1` (This is the statically assigned ipv6 ip in the [greybus demo program](https://github.com/jadonk/greybus-for-zephyr/tree/a08b3c297e5ac597b93956a76aa2e64043b65f8e/samples/subsys/greybus/net).

### Setting up the Linux host: Linux kernel patching 
After flashing the target device and ensuring everything is in working order, I set up my Linux host device to try and connect to the BeagleConnect Freedom wirelessly. This required a 5.8.4 Linux Kernel with MikroBus patches (along with a few others). 
As I didn't want to experiment with a custom Kernel on my host device, I set up a [Virtualbox VM](https://www.virtualbox.org/) with Ubuntu, where I cloned the Kernel and on a new branch built it with the patches applied. There were some problems while building, in particular in the `mikrobus linux kernel driver`: 
```ld: drivers/misc/mikrobus/mikrobus_core.o: in function `mikrobus_board_register.cold':
mikrobus_core.c:(.text.unlikely+0x456): undefined reference to `clk_register_fixed_rate'
make: *** [Makefile:1139: vmlinux] Error 1```

I looked into that driver's sourcecode, and someone left a comment they are working on it, so I just commented out the line in question and it built fine. (Hopefully I will not regret it later).

I then installed all modules using `sudo make modules_install` and installed the kernel itself with `sudo make install`. On reboot the newly installed kernel failed to initialise with the below error:
```booted via startup_320)
Physical KASLR using RDRAND RDTSC...
Virtual KASLR using RDRAND RDTSC...
D
Decompressing Linux... Parsing ELF... Performing relocations... done.
Booting the kernel.
ACPI Error: AE_BAD_PARAMETER, During Region initialization (20200528/tbxf load-52
ACPI: Unable to load the System Description Tables
ACPI Error: Could not remove SCI handler (20200528/evmisc-251)
Kernel panic - not syncing: VFS: Unable to mount root fs on unknown-block(0,0)
CPU: O PID: 1 Comm: swapper Not tainted 5.8.4-00895-g797f3a30dd4f-dirty #2
Hardware name: innotek GmbH VirtualBox/VirtualBox, BIOS VirtualBox 12/01/2006
Call Trace:
panic+Oxee/Ox27c
mount_block_root+0x31c/0x32b
prepare_namespace +0x128/Ox152
? rest_init+0x7a/Ox?a
kernel_init+0x5/Oxf 6
ret_from_fork+Ox22/0x30
Kernel Offset: Oxe200000 from Oxffffffff81000000 (relocation range: Oxffffffff80000000-Oxffffffffbfffffff)
+--[ end Kernel panic - not syncing: VFS: Unable to mount root fs on unknown-block(0,0) ]---```

According to [an old question on askubuntu](https://askubuntu.com/questions/41930/kernel-panic-not-syncing-vfs-unable-to-mount-root-fs-on-unknown-block0-0), this is due to missing initramfs for the patched Kernel, so I generated `intrid` for that kernel `version` using `sudo update-initramfs -u -k version` (`version` in my case was `5.8.4-00895-g797f3a30dd4f-dirty`).
Then I updated the GRUB menu using `sudo update-grub` (and because I am running GRUB version >2, I ran `sudo update-grub2`). 
Unfortunately this still resulted in the same error and after spending some more time on it without any success I left it as is to push the project forward from a different angle.

**I will get back to this milestone once I hear back from the Beagleboard community/get an idea as to what may be wrong** Things I can still try to get it to work:
* Try patching the kernel on my host machine (may be a VM-specific bug)
* Try the patched kernel on a different distro, e.g. Arch (may be a distro-specifc bug)
* Try and patch the [Ubuntu Kernel](https://wiki.ubuntu.com/Kernel/BuildYourOwnKernel) with the mikrobus and greybus patches


### Setting up the Linux host: Buildroot
Because of the troubles I was having with setting up a patched Kernel, [Vaishnav](https://github.com/vaishnav98) suggested I try using [buildroot](https://buildroot.org/) instead. (As there is a complete image setup wtih gbridge installed, to be used as BeagleConnect Gateway, found [here](https://github.com/jadonk/beagleconnect/tree/master/sw/buildroot).


### Pinging Zephyr

In order to ping the BeagleConnect, first a different device (e.g. a BeagleConnect) needs to be flashed with a usb_uart_bridge [software](https://github.com/jadonk/msp430F55xx_usb_uart_bridge) to be able to communicate over IEEE 802.15.4

Follow the guide linked above.

Then using [`wpanusb` linux kernel driver](https://github.com/jadonk/wpanusb#configuring-6lowpan-address) you can ping it (first run modprobe.sh to find the usb_uart_bridge device, then `sudo scripts/lowpan.sh 2 5 && ip -6 monitor dev lowpan0` to assign an ipv6 address. It should now be visible when calling `ip addr show dev lowpan0` or `ip a show lowpan0`. **Last but very important step:** Make sure both devices are on the same channel, you can check which channel the BeagleConnect is on by calling `ieee802154 get_chan`, and then on the Linux machine run `iwpan list` to get phy number of the `lowpan0` device, and set the channel for the 802.15.4 device: `sudo iwpan phy {PHY NUMBER} set channel 0 {CHANNELNO}`


IIO are hardware devices/sensors builtin and are located at /sys/bus/iio/devices
